#!/usr/bin/env perl
#
# pcre2bot â€” pcre2test IRC bot
#
# Copyright (c) 2025 ryoskzypu
# MIT-0 License. See LICENSE for details.
#
# Description:
#   IRC bot that listens to specific user commands in a IRC channel, sends them
#   to pcre2test, then runs regex tests and displays its results in the channel.
#
# Usage:
#   See 'pcre2bot --help'.
#
# Commands:
#   pcre2bot can act as a simple IRC client and run input commands prepended with
#   a slash, e.g. /connect.
#   Also accepts chat !commands from authorized userhosts.
#
#   For the complete list of PoCo-IRC commands, see https://metacpan.org/pod/POE::Component::IRC#INPUT-EVENTS,
#   and https://en.wikipedia.org/wiki/List_of_Internet_Relay_Chat_commands.
#
#   New commands:
#     /ban        #channel [nick...]              ban nicks or hosts
#     /cycle      #channel,... [message]          leave and rejoin channels
#     /dehalfop   #channel nick...                remove channel half-operator status from nicks
#     /deop       #channel nick...                "              operator      "
#     /devoice    #channel nick...                "              voice         "
#     /dumpstate                                  dump current IRC state info
#     /halfop     #channel nick...                give channel half-operator status to nicks
#     /help                                       show /commands usage
#     /kickban    #channel nick [reason]          kick a user from channel and ban its host
#     /me         #channel,... message            send a CTCP action to channels or nicks
#     /msg        #channel,... message            alias of /privmsg
#     /op         #channel nick...                give channel operator status to nicks
#     /quiet      #channel [nick...]              quiet nicks or hosts
#     /reconnect                                  reconnect to the current connected server
#     /run        -a | -c=#channel,... command    run a command on all joined channels or specific channels
#     /unban      #channel nick...                unban nicks or hosts
#     /unquiet    #channel nick...                unquiet "
#     /voice      #channel nick...                give channel voice status to nicks
#     /whox       [name [o]]                      extended query list of users that match a name
#
# References:
#   https://en.wikipedia.org/wiki/IRC
#   https://www.rfc-editor.org/rfc/rfc1459
#   https://modern.ircdocs.horse/
#   https://ircv3.net/irc/
#   https://www.perl.com/pub/2001/01/poe.html/
#   https://www.perl.com/pub/2004/07/02/poeintro.html/
#   https://pcre2project.github.io/pcre2/doc/pcre2test/
#
# Contributors:
#   OnlineCop
#
# Aknowledgements:
#   - https://github.com/PCRE2Project/pcre2/
#   - https://metacpan.org/dist/POE
#   - https://metacpan.org/dist/POE-Component-IRC
#   - https://github.com/geirha/shbot
#   - https://github.com/perlbot/perlbuut
#   - https://wooledge.org/~greybot/
#   - https://github.com/troydm/shellbot
#   - BinGOs, Mathizen, and folks from #perl on Libera (vague, huf, Grinnz, mauke,
#     Botje), OnlineCop #regex on Libera.
#
# Notes:
#   - Unfortunately to get TLS support, POE::Component::SSLify has to be force
#     installed because it's failing the tests.
#     Net::SSLeay also is failing its tests.
#
#   - The NICKSERV_PASS environment variable can be set, so the script will prefer
#     it over the config file password.
#
#   - pcre2bot uses Unix convention of exit codes, i.e. 0 success, 1 general failure,
#     2 command-line usage error.
#
#   - Make sure to have enough disk space when enabling logging, because the logger
#     just writes to its files in append mode. Also the script has no logrotate
#     mechanism, so the user has to take care of files management.
#
#   - pcre2bot has no mechanism to reload its config file in-place, because the
#     bot has to reconnect to apply the changes anyway.
#     Thus it is simpler to just edit the config and restart pcre2bot, or run
#     'systemd restart pcre2bot' if service is enabled.
#
# TODO:
#   - Study the IRC protocol basics.
#   - Study POE, and POE::Component::IRC, Mojo::IRC, AnyEvent::IRC.
#   - Study perlbot, shbot, and greybot to get ideias of useful features to implement.
#
#   - Study on how to implement perl modules/packages to the script, because it's
#     too long.
#
#   - Try to connect the bot with Tor. SOCKS5 is not supported, so maybe open a
#     feature issue to PoCo-IRC?
#     It seems Libera Chat only supports Tor with SASL, and PoCo-IRC does not
#     support SASL.
#
#   - Maybe add netcat support for pastebin services, so services that rely on
#     'nc' can be used.
#   - Add bash tab completions.
#   - Create a makefile to install all files, or use ExtUtils::MakeMaker.
#
#   - Think of ways of securing the bot e.g. sandboxing using virtualization,
#     linux namespaces, containers, etc.
#     Add a firejail profile.
#
#   - Add a log rotation to the logs with logrotate, document it, and provide
#     an example config.
#
#   - Study ways of how the bot can be deployed in a server.
#   - After POE script is done, maybe try to reimplement it with another framework,
#     e.g. Mojo::IRC.
#
#   - Add an AUR pcre2bot package.

use v5.26.0;

use strict;
use warnings;
use sigtrap 'handler' => \&sig_handler, qw< TERM >;  # Handle TERM signal sent by systemctl's stop/restart.
use open    qw< :std :encoding(UTF-8) >;             # Encode STDIN, STDOUT and STDERR to UTF-8.

use I18N::Langinfo        qw< langinfo CODESET >;
use Encode                qw< decode >;
use File::Basename;
use Getopt::Long          qw< GetOptions :config gnu_getopt >;
use TOML::Tiny            qw< from_toml >;
use POE                   qw<
                              Wheel::Run
                              Wheel::ReadWrite
                              Wheel::ReadLine
                              Component::IRC
                              Component::IRC::State
                              Component::IRC::Plugin::NickServID
                              Component::IRC::Plugin::Connector
                              Component::IRC::Plugin::Logger
                          >;
                             #Component::Curl::Multi  # PoCo-Curl is failing to build for latest libcurl because of Net::Curl header issue, re-add it when upstream fix it.
use IRC::Utils            qw< parse_user matches_mask >;
use HTTP::Request::Common qw< POST >;
use Data::Dumper          qw< Dumper >;
use POSIX                 qw< strftime >;

END { close STDOUT or die $! }

# Global variables

# Get the locale encoding and decode the command-line arguments.
{
    my $codeset = langinfo(CODESET);
    @ARGV = map { decode $codeset, $_ } @ARGV;
}

$|++;  # Disable STDOUT buffering.

my $prog     = basename $0;
my $prog_ver = '0.1';

# POE
my $irc;
my $readline;
my $curl;

# Handle signals.
sub sig_handler
{
    my $sig_name = shift;

    # Exit cleanly if SIGTERM is caught, e.g. via 'systemctl stop pcre2bot.service'.
    if ($sig_name eq 'TERM') {
        warn "Signal '${sig_name}' caught. Exiting.\n";
        $irc->yield('shutdown') if defined $irc;
    }
}

# Handle warnings.
local $SIG{__WARN__} = sub {
    my ($msg) = @_;

    # Format warnings when POE's ReadLine is set, so they are shown correctly.
    if (defined $readline) {
        $msg =~ s/\n\z//;
        $readline->put($msg);
    } else {
        warn $msg;
    }
};

my $usage = <<~"END";
    Usage: $prog [OPTION]... CONFIG_FILE
    pcre2test IRC bot
    IRC bot that listens to specific user commands in a IRC channel, sends them
    to pcre2test, then runs regex tests and displays its results in the channel.

    Options:
          --ac, --auto-conn auto-connect to server on start
      -d, --debug           show debug info
      -h, --help            show this help and exit
      -p, --pass            accepts STDIN as NickServ password
      -v, --version         show version info and exit

    Examples:
      $prog --ac CONFIG_FILE
    END

my $commands = <<~'END';
    Commands:
      For the complete description of PoCo-IRC commands, see https://metacpan.org/pod/POE::Component::IRC#INPUT-EVENTS,
      and https://en.wikipedia.org/wiki/List_of_Internet_Relay_Chat_commands.

      /admin      [server]                                          query server's admin info
      /away       [message]                                         set or remove away status
      /cap        end | ls | list | ack cap... | req cap...         query/enable/disable IRC protocol capabilities
      /connect                                                      connect to the server from config file
      /ctcp       #channel,... message                              send a CTCP query to channels or nicks
      /ctcpreply  #channel,... message                              "           reply "
      /dcc        nick send file [blksize] [timeout] | nick chat    send a DCC SEND or CHAT request to a nick
      /dcc_accept cookie [file]                                     accept an incoming DCC connection from another host
      /dcc_chat   id data                                           send lines of data to a nick
      /dcc_close  id                                                terminate a DCC SEND or GET connection, and close DCC CHAT connections
      /dcc_resume cookie [file]                                     resume a DCC SEND file transfer
      /debug      [1 | 0]                                           turn POE's debugging mode on or off
      /die                                                          tell server to shutdown
      /info       [server]                                          query server's info
      /invite     nick #channel                                     invite nick to a channel
      /ison       nick...                                           check if nicks are currently online
      /join       #channel [key]                                    join a channel
      /kick       #channel nick [message]                           kick a user from channel
      /links      [[server] mask]                                   query list of servers connected to the IRC network
      /list       [#channel...]                                     list visible channels and their topics
      /locops     message                                           send a message to all local-opers (+l) on EFNet
      /mode       #channel mode [mask]                              change a channel or nick mode
      /motd                                                         query server's 'Message of the Day'
      /names      #channel...                                       list nicks from channels
      /nick       nick                                              change current nick
      /nickserv   ...                                               send a message to NickServ
      /notice     #channel,... message                              send a notice message to channels or nicks
      /oper       user password                                     get server's operator privileges
      /operwall   message                                           send a message to all global opers on EFNet
      /part       #channel,... message                              leave channels
      /ping       server                                            send a ping to server
      /pong       server                                            answer a ping message
      /privmsg    #channel,... message                              send a message to channels or nicks
      /quit       [message]                                         disconnect from server
      /quote      string                                            send a raw string to server
      /register   event,...                                         register events to POE's session
      /rehash                                                       tell server to reload its config file
      /remove     #channel nick [message]                           force a nick to leave a channel
      /restart                                                      tell server to restart itself
      /sconnect   server [port] [remote]                            tell a server to connect to another
      /servlist   [mask [type]]                                     list services currently connected to the network
      /shutdown   [message [timeout]]                               disconnect from server and shutdown POE's session
      /squery     #channel,... message                              send a message to a service
      /squit      server message                                    disconnect server links
      /stats      [query [server]]                                  query statistics about server
      /summon     user [server [#channel]]                          give users from server a message asking them to please join IRC
      /time       [server]                                          query local time from server
      /topic      #channel [string]                                 get or set a channel's topic
      /trace      [server]                                          find the route to a server or nick
      /unregister event,...                                         unregister events from POE's session
      /userhost   nick...                                           query info about nicks
      /users      [server]                                          query count of users who are logged-in to a server
      /version    [server]                                          query server's version info
      /wallops    message                                           send a message to all opers (and +w users)
      /who        [name [o]]                                        query list of users that match a name
      /whois      [nick...]                                         query info about nicks or hostmasks
      /whowas     nick [count [server]]                             query info about offline nick

    New commands:
      /ban        #channel [nick...]              ban nicks or hosts
      /cycle      #channel,... [message]          leave and rejoin channels
      /dehalfop   #channel nick...                remove channel half-operator status from nicks
      /deop       #channel nick...                "              operator      "
      /devoice    #channel nick...                "              voice         "
      /dumpstate                                  dump current IRC state info
      /halfop     #channel nick...                give channel half-operator status to nicks
      /help                                       show /commands usage
      /kickban    #channel nick [reason]          kick a user from channel and ban its host
      /me         #channel,... message            send a CTCP action to channels or nicks
      /msg        #channel,... message            alias of /privmsg
      /op         #channel nick...                give channel operator status to nicks
      /quiet      #channel [nick...]              quiet nicks or hosts
      /reconnect                                  reconnect to the current connected server
      /run        -a | -c=#channel,... command    run a command on all joined channels or specific channels
      /unban      #channel nick...                unban nicks or hosts
      /unquiet    #channel nick...                unquiet "
      /voice      #channel nick...                give channel voice status to nicks
      /whox       [name [o]]                      extended query list of users that match a name
    END

# Input /commands
my @commands = (
    '/admin ',
    '/away ',
    '/ban ',
    '/cap ',
    '/connect ',
    '/ctcp ',
    '/ctcpreply ',
    '/cycle ',
    '/dehalfop ',
    '/deop ',
    '/devoice ',
    '/dcc ',
    '/dcc_accept ',
    '/dcc_chat ',
    '/dcc_close ',
    '/dcc_resume ',
    '/debug ',
    '/dumpstate',
    '/die',
    '/halfop ',
    '/help',
    '/info ',
    '/invite ',
    '/ison ',
    '/join ',
    '/kickban ',
    '/kick ',
    '/links ',
    '/list ',
    '/locops ',
    '/mode ',
    '/motd',
    '/me ',
    '/msg ',
    '/names ',
    '/nick ',
    '/nickserv ',
    '/notice ',
    '/oper ',
    '/op ',
    '/operwall ',
    '/part ',
    '/ping ',
    '/pong ',
    '/privmsg ',
    '/quiet ',
    '/quit ',
    '/quote ',
    '/register ',
    '/rehash',
    '/remove ',
    '/reconnect',
    '/restart',
    '/run ',
    '/sconnect ',
    '/servlist ',
    '/shutdown ',
    '/squery ',
    '/squit ',
    '/stats ',
    '/summon ',
    '/time ',
    '/topic ',
    '/trace ',
    '/unban ',
    '/unquiet ',
    '/unregister ',
    '/userhost ',
    '/users ',
    '/version ',
    '/voice ',
    '/wallops ',
    '/who ',
    '/whois ',
    '/whowas ',
    '/whox ',
);

# Options
my $auto_conn = 0;
my $debug     = 0;
my $pass      = 0;

# Configuration
my $config;
my $nickname          = '';
my $username          = '';
my $ircname           = '';
my $usermode          = '';
my $server            = '';
my $port              = '';
my $tls               = 0;
my $tls_cert          = '';
my $tls_key           = '';
my $log_path          = '';
my $log_private       = 0;
my $log_public        = 0;
my $log_raw           = 0;
my $nickserv_pass     = '';
my @channels          = ();
my @userhosts_allow   = ();
my @userhosts_ignore  = ();
my @userhosts_auth    = ();
my $def_pat_mods      = '';
my $def_subj_mods     = '';
my @pat_mods_allow    = ();
my @subj_mods_allow   = ();
my $max_irc_lines     = 0;
my $max_paste_lines   = 0;
my $primary_service   = '';
my @fallback_services = ();

# Log filehandles
my $main_log_fh;
my $raw_log_fh;

# pcre2bot's userhost and fullnick that IRC server sees.
my $userhost;  # ~user@host
my $fullnick;  # nick!~user@host

# pcre2test's output lines
my @lines;

# Regexes
my $num_rgx       = qr/\A\d++\z/;
my $pcre2_ver_rgx = qr/\APCRE2 version \d{2}+\.\d{2}+ \d{4}+-\d{2}+-\d{2}+\z/;
my $delimiter_rgx = qr{[/!"'`=_:;,%&@~-]}x;
my $mod_short_rgx = qr/\b(?> [agimnrsBI]++ | x{1,2}+)++\b/x;
my $commands_rgx  = qr/
                        (?>
                            (?'cmd1' help) | (?'cmd2' version)
                        )
                        |
                        (?'in_cmd' ![^\n]++)
                    /x;

# Flags
my $interactive   = (-t STDIN && -t STDOUT ? 1 : 0);  # Wheter script is running interactively, i.e. connected to a TTY.
my $connected     = 0;                                # Got connected to an IRC server.
my $was_connected = 0;                                # Was "
my $conv_uniq     = 0;                                # Unique conversion ('replace' modifier)
my $subj_literal  = 0;                                # subject_literal modifier
my $no_service    = 0;                                # Primary pastebin service

# Utils

# Handle pcre2bot errors
sub err
{
    my ($code, $msg) = @_;

    print STDERR "${prog}: ${msg}\n";

    $readline = '';
    exit $code;
}

# Auto-join channels
sub join_channels { $irc->yield(join => $_) foreach @channels }

# Print debug message.
sub pdbg
{
    return unless $debug;
    my ($msg) = @_;

    pput(1, $msg);
}

# Print Dumper formated output.
sub pdump
{
    return unless $debug;

    my ($str, $ref) = @_;

    # Newlines need to be stripped to be correctly shown on POE's ReadLine output.
    pput(1, $_) foreach (split /\n/, "$str = " . Dumper $ref);
}

# If the script is running interactively, send string to POE's ReadLine, so it
# can be shown correctly; otherwise print the string to file descriptor (STDOUT/STDERR).
sub pput
{
    my ($fd, $str) = @_;

    if ($interactive) {
        $readline->put("$str");
    }
    else {
        # STDOUT
        if ($fd == 1) {
            print "${str}\n";
        }
        # STDERR
        elsif ($fd == 2) {
            warn "${str}\n";
        }
    }
}

# Print a message with a timestamp to file descriptor (STDOUT/STDERR) or log file.
# Note that STDERR goes to the systemd's journal, if pcre2bot's service is enabled.
sub plog
{
    my ($fd, $log_to_file, $raw, $get_date, $message) = @_;

    my ($date, $time) = split / /, (strftime '%Y-%m-%d %H:%M:%S ', localtime);
    my $new_msg       = ($get_date == 1 ? "$date $time $message" : "$time $message");

    # Wheter to log irc_raw* events to 'raw.log' or main events to 'main.log'.
    my $fh = ($raw ? $raw_log_fh : $main_log_fh);

    # If pcre2bot is started non-interactively, i.e. via systemd service, do not
    # print a timestamp on systemd's journal, but keep them on logs.
    $new_msg = $message if ! $interactive && $log_to_file == 0;

    $log_to_file == 1 ? print $fh "${new_msg}\n"
                      : pput($fd, $new_msg);
}

# Print message to file descriptor (STDOUT/STDERR) and log it if config asks.
sub pmsg
{
    my ($fd, $raw, $msg) = @_;

    plog($fd, 0, 0, 0, $msg);

    # Log
    if ($log_path ne '') {
        # Only log irc_raw* events if config asks.
        if ($raw) {
            $log_raw ? plog($fd, 1, $raw, 1, $msg)
                     : return;
        } else {
            plog($fd, 1, 0, 1, $msg);
        }
    }
}

# Print an error message if the /command was sent interactively, otherwise send
# a response error message.
sub perr
{
    my ($channel, $nick, $message) = @_;

    $channel eq '' ? pput(1, $message)
                   : $irc->yield(privmsg => $channel => "${nick}${message}");
}

# Dump PRIVMSG messages for debugging.
sub dump_privmsg
{
    my ($message) = @_;
    my @bytes = split //, $message;

    @bytes = map { conv_chars($_) } @bytes;
    my $dumped_msg = join '', @bytes;

    pdbg("\$dumped_msg: '${dumped_msg}'");
}

# Convert non-printable chars to their escaped, octal, or hex representation.
# E.g. \t, \o{011}, or \x{09} respectively. See ascii(7).
sub conv_chars
{
    my $char = shift;

    # Decimal to escaped chars table
    my %esc_chars = (
        '0'  => '\0',
        '7'  => '\a',
        '8'  => '\b',
        '9'  => '\t',
        '10' => '\n',
        '11' => '\v',
        '12' => '\f',
        '13' => '\r',
    );

    # Control but escaped chars
    if ($char =~ /\A[\x{01}-\x{06}\x{0e}-\x{1f}]\z/) {
        return sprintf "\\o{%03o}", ord $char;  # Octal
    }
    # Escaped
    elsif ($char =~ /\A[\x{00}\x{07}-\x{0d}]\z/) {
        return sprintf '%s', $esc_chars{ord $char};
    }
    # Printable ASCII (7-bit)
    elsif ($char =~  /\A[\x{20}-\x{7e}]\z/) {
        return $char;
    }
    # Non-printable ASCII and non-ASCII (Unicode)
    else {
        return sprintf "\\x{%x}", ord $char;  # Hex
    }
}

# Convert Unix epoch time to human-readable date.
sub conv_date
{
    my ($epoch) = @_;

    # E.g. Wed, 16 Apr 2025 06:49:34
    return strftime "%a, %d %b %Y %T", localtime $epoch;
}

# Check if userhost (~user@host) is allowed to run bot commands.
sub is_userhost_allowed
{
    my ($userhost) = @_;

    # Allow list has priority over the ignore list.
    if (! @userhosts_allow) {
        if (grep { $_ eq $userhost } @userhosts_ignore) {
            pdbg("ignored '${userhost}' userhost sent a message");
            return 0;
        } else {
            #pdbg("userhost '${userhost}' sent a message");
            return 1;
        }
    }

    if (grep { $_ eq $userhost } @userhosts_allow) {
        #pdbg("allowed '${userhost}' userhost sent a message");
        return 1;
    } else {
        pdbg("blocked '${userhost}' userhost sent a message");
        return 0;
    }
}

# Request a mode change on a specific channel.
sub set_chan_mode
{
    my ($privmsg_chan, $privmsg_nick, $args, $action, $mode, $err) = @_;
    my $channel  = shift $args->@*;
    my $args_len = scalar $args->@*;

    if (! defined $channel) {
        perr($privmsg_chan, $privmsg_nick, "missing channel");
        return;
    }

    if (! $args->@*) {
        perr($privmsg_chan, $privmsg_nick, "missing $err");
        return;
    }

    $action .= $mode x $args_len;

    # Set mode
    $irc->yield(mode => "$channel $action " . join ' ', $args->@*);
}

# Event handlers

sub _start
{
    my $heap = $_[HEAP];

    if ($log_path ne '') {
        # Log IRC events related to pcre2bot that are not supported by PoCo-IRC
        # Logger plugin, in a non-blocking way.
        $heap->{readwrite_main} = POE::Wheel::ReadWrite->new(
            Handle     => $main_log_fh,
            InputEvent => 'rw_handle_input',
            ErrorEvent => 'rw_error_state',
        );

        # Log irc_raw* events in a non-blocking way.
        if ($log_raw) {
            $heap->{readwrite_raw} = POE::Wheel::ReadWrite->new(
                Handle     => $raw_log_fh,
                InputEvent => 'rw_handle_input',
                ErrorEvent => 'rw_error_state',
            );
        }

        # Log IRC public, private, notice, DCC, and CTCP ACTIONs messages.
        # Note that irc_join/part/quit/nick/kick/mode/topic messages are also logged.
        $irc->plugin_add('Logger', POE::Component::IRC::Plugin::Logger->new(
                Path    => $log_path,
                Private => $log_private,
                Public  => $log_public,
                DCC     => 1,
                Notices => 1,
        ));
    }

    # Initialize POE's ReadLine, so pcre2bot can run user IRC /commands from TTY.
    if ($interactive) {
        $readline = POE::Wheel::ReadLine->new(
            InputEvent => 'rl_handle_input',
        );
        $readline->get('> ');

        # Add tab completions to PoCo-IRC commands.
        my $attribs = $readline->attribs;
        $attribs->{completion_function} = sub {
            my ($text, $line, $start) = @_;

            return @commands;
        };
    }

    $irc->yield(register => 'all');
    $irc->yield(connect  => {}) if $auto_conn;

    return;
}

# Print registered PoCo-IRC events that are not handled by a subroutine, for debug info.
sub _default
{
    return unless $debug;

    my ($event, $args) = @_[ARG0 .. $#_];

    # Ignore events that are already handled by irc_raw* subroutines.
    if ($event =~ /
                      \A
                      irc_
                      (?>
                          \d{3}+
                          | away
                          | bot_public
                          | bot_msg
                          | cap
                          | chan_mode
                          | notice
                          | ping
                          | snotice
                          | user_mode
                          | wallops
                      )
                      \z
                  /x) {
        return;
    }

    my @output = ("${event}: ");

    foreach my $arg ($args->@*) {
        if (ref $arg eq 'ARRAY') {
            push @output, '[' . join(', ', $arg->@*) . ']';
        }
        elsif (ref $arg eq 'HASH') {
            push @output, '{' . join(', ', $arg->%*) . '}';
        }
        elsif (defined $arg) {
            push @output, "'${arg}'";
        }
    }

    plog(1, 0, 0, 0, "@output");
    return;
}

# Handle PoCo-Curl's HTTP requests responses.
sub _response
{
    my ($heap, $request_packet, $response_packet) = @_[HEAP, ARG0, ARG1];
    my $ret_code = $response_packet->[0]->{_rc};
    my $content  = $response_packet->[0]->{_content};
    $content =~ s/\n//;

    my $channel = $heap->{channel};
    my $nick    = $heap->{nick};
    my $input   = $heap->{input};
    my $url     = $primary_service;

    #pdump '$request_packet',  $request_packet;
    #pdump '$response_packet', $response_packet;

    pdbg("${ret_code}: '${content}'");

    # Success.
    if ($ret_code == 200) {
        $irc->yield(privmsg => $channel => "${nick}etc... ( $content )");
    }
    # Try a fallback service.
    else {
        if (! @fallback_services) {
            $irc->yield(privmsg => $channel => "failed to upload pcre2test's output to a pastebin service");
            return;
        }

        $url = shift @fallback_services;
        get_pastebin($input);
    }

    return;
}

# Handle POE's ReadWrite input events.
# Note that for some reason no input is getting caught by this handle.
sub rw_handle_input
{
    my ($input, $wheel_id) = @_[ARG0, ARG1];

    pdbg("echoing input from wheel ${wheel_id}: $input");
}

# Handle POE's ReadWrite error events.
# Note that for some reason this handler shows a 'Bad file descriptor' error event.
sub rw_error_state
{
    my ($operation, $errnum, $errstr, $id) = @_[ARG0..ARG3];

    if ($operation eq 'read' and $errnum == 0) {
        pdbg("EOF from wheel $id");
    }
    else {
        pdbg("wheel $id encountered $operation error ${errnum}: $errstr");
    }

    delete $_[HEAP]{readwrite_main}{$id};  # Shut down that wheel.
}

# Handle POE's ReadLine input events.
sub rl_handle_input
{
    my ($kernel, $input, $exception) = @_[KERNEL, ARG0, ARG1];

    if (defined $input) {
        $readline->addhistory($input);
        parse_command('', '', $input);
    }
    # Exit cleanly after Ctrl+c and Ctrl+d inputs.
    elsif ($exception =~ /\A(?> eot | interrupt)\z/x) {
        $irc->yield('shutdown');
    }

    $readline->get('> ') if $readline;
    return;
}

# Parse POE's ReadLine inputs to run /commands or authorized PRIVMSGs to run !commands.
#
# References:
#   https://metacpan.org/pod/POE::Component::IRC#INPUT-EVENTS
#   https://weechat.org/files/doc/weechat/stable/weechat_user.en.html#irc_commands
#   https://weechat.org/files/doc/weechat/stable/weechat_user.en.html#weechat_commands
#   https://libera.chat/guides/channelmodes
#   https://libera.chat/guides/quickops
#
# Notes:
#   - The input strings are split by spaces, so mentions of 'arguments' means
#     strings that do not contain spaces, and plain 'string' is the opposite.
#
#   - Some commands, (e.g. privmsg, notice, ctcp, etc) accept multiple channels/nicks
#     with a comma separator (e.g. /privmsg #chan1,#chan2 message).
#
#   - Since arguments are split by spaces, it can cause problems with dcc* commands,
#     because of filenames that contain spaces. This can be fixed, but pcre2bot
#     is not intended for DCC usage.
#
#   - Some commands that take N arguments like nickserv can accept passwords, so
#     a password will be parsed wrong if it contain spaces.
#     I'm not sure if all IRC servers accept spaces in nickserv passwords. It seems
#     that Libera does accept them in 'nickserv set password', 'nickserv identify',
#     but not in 'nickserv register'.
#
#   - For some reason part, quit and shutdown commands only send the optional
#     message argument to the server after being connected for some time.
sub parse_command
{
    my ($privmsg_chan, $privmsg_nick, $input) = @_;

    if ($input =~ s|\A/||) {
        my (@args) = split / /, $input;
        my ($cmd)  = shift @args;

        pdump('@args', \@args);

        # Commands that take 1 argument and a string.
        if ($cmd =~ /
                           \A
                           (?>
                               ctcpreply
                               | ctcp
                               | notice
                               | squery
                               | squit
                           )
                           \z
                       /x) {
            my $channels = shift @args;

            $irc->yield($cmd => $channels => "@args");
        }
        # Commands that take 2 arguments and a string.
        elsif ($cmd =~ /
                           \A
                           (?>
                               kick
                               | remove
                           )
                           \z
                       /x) {
            my $channel = shift @args;
            my $nick    = shift @args;

            $irc->yield($cmd => $channel => $nick => "@args");
        }
        # Commands that take a single string.
        elsif ($cmd =~ /
                           \A
                           (?>
                               away
                               | locops
                               | operwall
                               | quit
                               | quote
                               | wallops
                               | who
                           )
                           \z
                       /x) {
            $irc->yield($cmd => "@args");
        }
        elsif ($cmd eq 'connect') {
            if ($irc->connected) {
                perr($privmsg_chan, $privmsg_nick, "already connected to $server");
                return;
            }
            else {
                pput(1, "connecting to $server on port $port");
                $irc->yield('connect');
            }
        }
        # Ban/unban or quiet/unquiet nicks or hosts.
        #   /ban     #channel [nick...]
        #   /unban   #channel nick...
        #
        #   /quiet   #channel [nick...]
        #   /unquiet #channel nick...
        #
        # If the nick is present in channel, (un)ban/quiet its hostname in a mask i.e. *!*@host.
        #
        # Note that the /mode command sets automatic masks wether the victim string
        # looks like a nick or a @host, (e.g. *!*@host, nick!*@*); it does not if
        # it is a mask string.
        # Without argument, show the channel's ban/quiet list.
        elsif ($cmd =~ /
                           \A
                           (?>
                               (?'unban'   unban)
                               |
                               (?'unquiet' unquiet)
                               |
                               (?'ban'     ban)
                               |
                               (?'quiet'   quiet)
                           )
                           \z
                       /x) {
            my $channel  = shift  @args;
            my $args_len = scalar @args;
            my $action   = '';
            my $type     = '';
            my @victim_list;

            if (! defined $channel) {
                perr($privmsg_chan, $privmsg_nick, "missing channel");
                return;
            }

            # Set mode's action.
            if (defined $+{unban} || defined $+{unquiet}) {
                $action = '-';
            } elsif (defined $+{ban} || defined $+{quiet}) {
                $action = '+';
            }

            # Set mode's type.
            if (defined $+{unban} || defined $+{ban}) {
                $type = 'b';
            } elsif (defined $+{unquiet} || defined $+{quiet}) {
                $type = 'q';
            }

            if (! @args) {
                if ($action eq '-') {
                    perr($privmsg_chan, $privmsg_nick, "missing nick or host");
                }
                # Show channel's ban/quiet list.
                elsif ($action eq '+') {
                    if (defined $+{ban}) {
                        $irc->yield(mode => "$channel $type");
                    }
                    elsif (defined $+{quiet}) {
                        $irc->yield(mode => "$channel $type");
                    }
                }

                return;
            }

            $action .= $type x $args_len;

            # Parse args
            foreach my $victim (@args) {
                # If nick is in channel, ban/unban or quiet/unquiet its host in a mask.
                if ($irc->is_channel_member($channel, $victim)) {
                    my $nick_info = $irc->nick_info($victim);
                    my $host      = $nick_info->{Host};

                    pdbg("$victim is in $channel");
                    pdump('$irc->nick_info', $nick_info);

                    $victim = "*!*\@${host}";
                }

                push @victim_list, $victim;
            }

            # Ban/unban
            $irc->yield(mode => "$channel $action @victim_list");
        }
        # Leave channels with an optional message and rejoin them.
        #   /cycle #channel,... [message]
        elsif ($cmd eq 'cycle') {
            my $message  = '';
            my $args_len = scalar @args;

            if (! @args) {
                perr($privmsg_chan, $privmsg_nick, "missing channels");
                return;
            }

            # Get /part message if any.
            if ($args_len > 1 && $args[-1] !~ /\A#/) {
                $message = pop @args;
            }

            # Cycle
            $irc->yield(part => @args, $message);
            $irc->yield(join => $_) foreach (@args);
        }
        # Remove channel half-operator status from nicks
        #   /dehalfop #channel nick...
        elsif ($cmd eq 'dehalfop') {
            set_chan_mode($privmsg_chan, $privmsg_nick, \@args, '-', 'h', 'nicks');
        }
        # Remove channel operator status from nicks
        #   /deop #channel nick...
        elsif ($cmd eq 'deop') {
            set_chan_mode($privmsg_chan, $privmsg_nick, \@args, '-', 'o', 'nicks');
        }
        # Remove channel voice status from nicks.
        #   /devoice #channel nick...
        elsif ($cmd eq 'devoice') {
            set_chan_mode($privmsg_chan, $privmsg_nick, \@args, '-', 'v', 'nicks');
        }
        # Dump IRC state info.
        elsif ($cmd eq 'dumpstate') {
            pdump('$state', $irc->{STATE});
        }
        # Give channel half-operator status to nicks.
        #   /halfop #channel nick...
        elsif ($cmd eq 'halfop') {
            set_chan_mode($privmsg_chan, $privmsg_nick, \@args, '+', 'h', 'nicks');
        }
        elsif ($cmd eq 'help') {
            pput(1, $commands);
        }
        # Kick a user from channel and ban its host.
        #   /kickban #channel nick [reason]
        #
        # If the nick is present in channel, ban its hostname in a mask i.e. *!*@host,
        # before the kick.
        elsif ($cmd eq 'kickban') {
            my $channel = shift @args;

            if (! defined $channel) {
                perr($privmsg_chan, $privmsg_nick, "missing channel");
                return;
            }

            if (! @args) {
                perr($privmsg_chan, $privmsg_nick, "missing nick");
                return;
            }

            my $nick      = shift @args;
            my $nick_orig = $nick;
            my $reason    = "@args";

            # If nick is in channel, ban its host in a mask.
            if ($irc->is_channel_member($channel, $nick)) {
                my $nick_info = $irc->nick_info($nick);
                my $host      = $nick_info->{Host};

                pdbg("$nick is in $channel");
                pdump('$irc->nick_info', $nick_info);

                $nick = "*!*\@${host}";
            }
            else {
                pdbg("$nick is not in $channel");
            }

            # Ban
            $irc->yield(mode => "$channel +b $nick");

            # Kick
            $irc->yield(kick => $channel => $nick_orig => $reason) if $nick ne $nick_orig;
        }
        # Send a CTCP action to channels/nicks.
        #   /me #channel,... message
        elsif ($cmd eq 'me') {
            my $channels = shift @args;

            if (! defined $channels) {
                perr($privmsg_chan, $privmsg_nick, "missing channels or nicks");
                return;
            }

            $irc->yield(ctcp => $channels => 'ACTION ' . "@args");
        }
        # Without argument, request a MODE on pcre2bot's nick.
        elsif ($cmd eq 'mode') {
            @args ? $irc->yield($cmd => "@args")
                  : $irc->yield($cmd => $nickname);
        }
        # Give channel half-operator status to nick.
        #   /op #channel nick...
        elsif ($cmd eq 'op') {
            set_chan_mode($privmsg_chan, $privmsg_nick, \@args, '+', 'o', 'nicks');
        }
        # Send a public/private message to specific channels or nicks.
        #   /privmsg #channel,... message
        #   /msg     "
        elsif ($cmd =~ /
                           \A
                           (?>
                               privmsg | msg
                           )
                           \z
                       /x) {
            my $channels = shift @args;

            if (! defined $channels) {
                perr($privmsg_chan, $privmsg_nick, "missing channels or nicks");
                return;
            }

            $irc->yield(privmsg => $channels => "@args")
        }
        elsif ($cmd eq 'reconnect') {
            if ($irc->connected) {
                perr($privmsg_chan, $privmsg_nick, "reconnecting to $server on port $port");
                $irc->yield('quit');

                # Wait 5 seconds before reconnecting, to give the script time to quit.
                $irc->delay(['connect'], 5);
            }
            else {
                pput(1, "not connected to a server");
                return;
            }
        }
        # Run a command on all joined channels or specific channels.
        #   /run -a | -c=#channel,... command
        #
        # Note that it is only useful for some commands that do not accept multiple
        # channels.
        elsif ($cmd eq 'run') {
            my $option  = shift @args;
            my $cmdname = shift @args;
            my $all     = 0;
            my @channels;

            # Parse options
            #
            # Note that options are 'short' because POE's ReadLine does not tab-complete
            # multiple options.
            if (defined $option) {
                # All channels
                if ($option eq '-a') {
                    $all = 1;
                }
                # Specific channels
                elsif ($option =~ /\A-c=\K[^\x{20}]*+\z/) {
                    @channels = split /,/, $&;
                    pdump('@channels', \@channels);

                    if (! @channels) {
                        perr($privmsg_chan, $privmsg_nick, "missing channels");
                        return;
                    }
                }
                else {
                    perr($privmsg_chan, $privmsg_nick, "invalid '${option}' option");
                    return;
                }
            }

            if (! defined $cmdname) {
                perr($privmsg_chan, $privmsg_nick, "missing command argument");
                return;
            }

            # Do not accept 'run' command to avoid infinite recursion.
            if (defined $cmdname && $cmdname eq '/run') {
                perr($privmsg_chan, $privmsg_nick, "/run command is not valid");
                return;
            }

            # Run
            if ($all) {
                if (! $irc->channels->%*) {
                    perr($privmsg_chan, $privmsg_nick, "pcre2bot has not joined in any channel");
                    return;
                }

                pdump('$irc->channels', $irc->channels);

                # Iterate on currently joined channels.
                foreach my $channel (keys $irc->channels->%*) {
                    my $command = "$cmdname $channel @args";

                    pdbg("running '${command}' on $channel");
                    parse_command($privmsg_chan, $privmsg_nick, $command);
                }
            } else {
                foreach my $channel (@channels) {
                    my $command = "$cmdname $channel @args";

                    pdbg("running '${command}' on $channel");
                    parse_command($privmsg_chan, $privmsg_nick, $command);
                }
            }
        }
        elsif ($cmd eq 'topic') {
            my $channel = shift @args;

            if (@args) {
                # "" or '' unsets the topic.
                if ("@args" =~ /\A(?> "" | '')\z/x) {
                    $irc->yield($cmd => $channel => '');
                }
                # Set topic with args string.
                else {
                    $irc->yield($cmd => $channel => "@args");
                }
            } else {
                # Get the current topic.
                $irc->yield($cmd => $channel);
            }
        }
        # Give channel voice status to nicks.
        #   /voice #channel nick...
        elsif ($cmd eq 'voice') {
            set_chan_mode($privmsg_chan, $privmsg_nick, \@args, '+', 'v', 'nicks');
        }
        # Without argument, request a WHOIS on pcre2bot's nick.
        elsif ($cmd eq 'whois') {
            @args ? $irc->yield($cmd => @args)
                  : $irc->yield($cmd => $nickname);
        }
        # Extended query list of users that match a name.
        #   /whox [name [o]]
        #
        # Useful to get account name info. See https://ircv3.net/specs/extensions/whox.
        elsif ($cmd eq 'whox') {
            my $name = shift @args;
            $irc->yield('quote' => "WHO $name %cuihsnfdlaor");
        }
        # Commands that take N arguments.
        else {
            $irc->yield($cmd => @args);
        }
    }

    return;
}

# Handle pcre2test's STDOUT events.
sub got_child_stdout
{
    my ($heap, $stdout_line, $wheel_id) = @_[HEAP, ARG0, ARG1];

    my $child     = $heap->{children_by_wid}{$wheel_id};
    my $child_pid = $child->PID;
    my $channel   = $heap->{channel};
    my $nick      = $heap->{nick};
    my $line_cnt  = scalar @lines;

    pdbg("PID $child_pid STDOUT: '${stdout_line}'");
    pdbg("\$line_cnt: $line_cnt");

    return if $line_cnt == $max_paste_lines;

    # Warn if pastebin primary service is not set.
    if ($primary_service eq '') {
        if (! $no_service && $line_cnt == $max_irc_lines + 1) {
            $irc->yield(privmsg => $channel => "${nick}etc... ( primary pastebin service is not set )");
            $no_service = 1;

            return;
        }
        elsif ($no_service) {
            # Reset lines and flag on last line.
            if ($stdout_line eq '') {
                undef(@lines);
                $no_service = 0;
            }

            return;
        }
    }

    # Last output line.
    if ($stdout_line eq '') {
        # Send output to a pastebin service, if line count exceeds the limit.
        if ($line_cnt > $max_irc_lines + 1) {
            my $input = join "\n", @lines;
            $heap->{input} = $input;

            get_pastebin($input);
        }

        # Reset
        undef(@lines);
        $conv_uniq  = 0;
        $no_service = 0;

        # Close pcre2test's STDIN so pcre2bot can clean itself on got_child_close(),
        # and avoid memory usage problems.
        $child->shutdown_stdin;
    }
    else {
        # Convert back the escaped unique char to a comma. Note that pcre2test
        # also displays the unique '\034' char as a literal '\x{1c}' in hex notation.
        $stdout_line =~ s/\o{034} | \\x\{1c\}/,/gx if $conv_uniq;

        # Count all lines except the version line from command.
        if ($stdout_line !~ $pcre2_ver_rgx && $line_cnt <= $max_paste_lines - 1) {
            push @lines, $stdout_line;

            if ($line_cnt == $max_paste_lines - 1) {
                plog(2, 0, 0, 1, "line count exceeded the maximum number of paste lines: $max_paste_lines");

                # pcre2test must be killed after the limit, otherwise it will
                # continue to waste CPU and output its lines to STDOUT, i.e. it
                # consumes a lot of CPU on large callout outputs.
                my $rc = $child->kill();
                plog(2, 0, 0, 1, "pcre2test got killed with return code: $rc");

                #pdump('@lines', \@lines);
                return;
            }
        }

        # Ignore pcre2test's error/version messages.
        if ($stdout_line !~ /\A\*\* [^\n]++\z/ && $stdout_line !~ $pcre2_ver_rgx) {
            if ($heap->{trigger} =~ /\A(?> default | callouts)\z/x && $line_cnt < $max_irc_lines + 1) {
                # Ignore the first 2 lines if the trigger is a default or callout,
                # because pattern/subject is already known to the user.
                return if $line_cnt =~ /\A[01]\z/;

                # Send output to the channel.
                $irc->yield(privmsg => $channel, "${nick}$stdout_line");
            }
            elsif ($heap->{trigger} =~ /\Averbose\z/ && $line_cnt < $max_irc_lines - 1) {
                $irc->yield(privmsg => $channel, "${nick}$stdout_line");
            }
        } else {
            $irc->yield(privmsg => $channel, "${nick}$stdout_line");
        }
    }
}

# Handle pcre2test's STDERR events.
sub got_child_stderr
{
    my ($heap, $stderr_line, $wheel_id) = @_[HEAP, ARG0, ARG1];
    my $child     = $heap->{children_by_wid}{$wheel_id};
    my $child_pid = $child->PID;

    $child->shutdown_stdin;

    pdbg("PID $child_pid STDERR: $stderr_line");
}

# Handle pcre2test's close events.
sub got_child_close
{
    my ($heap, $wheel_id) = @_[HEAP, ARG0];
    my $child     = delete $heap->{children_by_wid}{$wheel_id};
    my $child_pid = $child->PID;

    # May have been reaped by on_child_signal().
    if (! defined $child) {
        pdbg("WID $wheel_id closed all pipes");
        return;
    }

    pdbg("PID $child_pid closed all pipes");

    # Cleaning
    undef(@lines);
    delete $heap->{children_by_pid}{$child_pid};
    delete $heap->{channel};
    delete $heap->{nick};
    delete $heap->{trigger};
    delete $heap->{input};
}

# Handle pcre2test's signal events.
sub got_child_signal
{
    my ($heap, undef, $child_pid, $status) = @_[HEAP, ARG0 .. ARG2];

    pdbg("PID $child_pid exited with status $status");
    my $child = delete $heap->{children_by_pid}{$child_pid};

    # May have been reaped by on_child_close().
    return unless defined $child;

    # Cleaning
    undef(@lines);
    delete $heap->{children_by_wid}{$child->ID};
    delete $heap->{channel};
    delete $heap->{nick};
    delete $heap->{trigger};
    delete $heap->{input};
}

# Events

# Server welcome message
# Note that this event is necessary to start sending commands to the server.
sub irc_001
{
    #my $heap   = $_[HEAP];
    my $server = $irc->server_name;

    $connected     = 1;
    $was_connected = 1;
    pmsg(2, 0, "Connected to $server");

    # Request useful IRCv3 capabilities.
    #
    # Note that the IRC server must support them. Run '/cap ls' to list the server
    # supported capabilities.
    #
    # See:
    #   https://modern.ircdocs.horse/#capability-negotiation
    #   https://ircv3.net/specs/extensions/capability-negotiation.html
    #   https://ircv3.net/registry#capabilities
    #   https://weechat.org/files/doc/weechat/stable/weechat_user.en.html#irc_ircv3_support
    my @caps = (
        qw<
            account-notify
            account-tag
            cap-notify
            chghost
            echo-message
            extended-join
        >
    );
    $irc->yield(cap => "req $_") foreach (@caps);

    # Identify to NickServ if a password is set.
    $irc->plugin_add('NickServID', POE::Component::IRC::Plugin::NickServID->new(
        'Password' => $nickserv_pass,
    )) if $nickserv_pass ne '' && $tls_cert eq '';

    $irc->yield(mode  => "$nickname $usermode") if $usermode ne '';
    $irc->yield(whois => $nickname)             if $nickserv_pass eq '';

    join_channels() if $nickserv_pass eq '';

    return;
}

# Print channel's creation time in human-readable format.
sub irc_329
{
    # E.g. ':calcium.libera.chat 329 pcre2bot #linux 1621426414'
    my ($server, $raw_msg, $msg_ref) = @_[ARG0 .. ARG2];
    my ($channel, $time) = $msg_ref->@*;

    $time = conv_date($time);

    pdump('$msg_ref', $msg_ref);
    plog(1, 0, 0, 0, "Channel $channel created on $time");
}

# Print channel's topic 'setby time' in human-readable format.
sub irc_333
{
    # E.g. ':zirconium.libera.chat 333 pcre2bot #linux nkukard 1722815284'
    my ($server, $raw_msg, $msg_ref) = @_[ARG0 .. ARG2];
    my ($channel, $setby, $time) = $msg_ref->@*;

    $time = conv_date($time);

    pdump('$msg_ref', $msg_ref);
    plog(1, 0, 0, 0, "Topic for $channel set by $setby on $time");
}

# Parse the extended WHO command, from /whox.
# https://ircv3.net/specs/extensions/whox
sub irc_354
{
    # E.g. ':mercury.libera.chat 354 pcre2bot #pcre2bot ~ryoskzypu 255.255.255.255 user/ryoskzypu copper.libera.chat ryoskzypu H 0 0 ryoskzypu n/a :ryoskzypu'
    my ($server, $raw_msg, $msg_ref) = @_[ARG0 .. ARG2];
    my ($channel, $user, $ip, $host, $sv, $nick, $flags, $hopcount, $idle, $account, $oplevel, $realname) = $msg_ref->@*;

    pdump('$msg_ref', $msg_ref);

    plog(1, 0, 0, 0, "channel  => $channel");
    plog(1, 0, 0, 0, "user     => $user");
    plog(1, 0, 0, 0, "ip       => $ip");
    plog(1, 0, 0, 0, "host     => $host");
    plog(1, 0, 0, 0, "server   => $sv");
    plog(1, 0, 0, 0, "nick     => $nick");
    plog(1, 0, 0, 0, "flags    => $flags");
    plog(1, 0, 0, 0, "hopcount => $hopcount");
    plog(1, 0, 0, 0, "idle     => $idle");
    plog(1, 0, 0, 0, "account  => $account");
    plog(1, 0, 0, 0, "oplevel  => $oplevel");
    plog(1, 0, 0, 0, "realname => $realname");
}

# Show channel's ban list in a human-readable format.
sub irc_367
{
    # E.g. ':tungsten.libera.chat 367 ryoskzypu #ryoskzypu *!*@user/foo ryoskzypu!~ryoskzypu@user/ryoskzypu 1744759984'
    my ($server, $raw_msg, $msg_ref) = @_[ARG0 .. ARG2];
    my ($channel, $victim, $setby, $setat) = $msg_ref->@*;

    $setat = conv_date($setat);

    pdump('$msg_ref', $msg_ref);
    plog(1, 0, 0, 0, "$victim banned by $setby on $setat");
}

# Log when someone is messaging pcre2bot and it has +g umode set (+g or +G on Libera
# and +g, +G, or +j on OFTC).
sub irc_718
{
    my ($server, $raw_msg, $msg_ref) = @_[ARG0 .. ARG2];
    my $nick     = $msg_ref->[0];
    my $userhost = $msg_ref->[1];
    my $message  = $msg_ref->[2];

    plog(1, 1, 0, 1, "$nick $userhost $message") if $log_path ne '';
    return;
}

# Show channel's quiet list in a human-readable format.
sub irc_728
{
    # E.g. ':tungsten.libera.chat 728 ryoskzypu #ryoskzypu q *!*@user/foo ryoskzypu!~ryoskzypu@user/ryoskzypu 1744759984'
    my ($server, $raw_msg, $msg_ref) = @_[ARG0 .. ARG2];
    my ($channel, $mode, $victim, $setby, $setat) = $msg_ref->@*;

    $setat = conv_date($setat);

    pdump('$msg_ref', $msg_ref);
    plog(1, 0, 0, 0, "$victim quieted by $setby on $setat");
}

# Print events received by the IRC server in original format.
sub irc_raw
{
    my $raw_msg = $_[ARG0];

    pmsg(1, 1, "->$raw_msg");
    return;
}

# Print events sent by the IRC server in original format.
sub irc_raw_out
{
    my $raw_out_msg = $_[ARG0];

    pmsg(1, 1, ">>> $raw_out_msg");
    return;
}

# Print and/or log when a connection to an IRC server is estabilished.
sub irc_connected
{
    my ($heap, $server) = @_[HEAP, ARG0];

    # Keep bot connected to the IRC server on disconnections.
    $heap->{connector} = POE::Component::IRC::Plugin::Connector->new;
    $irc->plugin_add('Connector' => $heap->{connector});

    if ($log_path ne '') {
        print $main_log_fh <<~_;
            ***
            *** LOGGING BEGINS
            ***
            _
    }

    pmsg(2, 0, "Connection to $server on port $port estabilished");

    return;
}

# If a NickServ password is set, only join channels after the nick is identified,
# so the hostname is not exposed before a cloak is set on some servers (e.g. Libera
# Chat and OFTC).
sub irc_identified
{
    #my $heap = $_[HEAP];

    pmsg(1, 0, "$nickname is identified by NickServ, joining channels");

    $irc->yield(whois => $nickname);
    join_channels();

    return;
}

# Query and log pcre2bot's WHOIS information after it connects to an IRC server.
sub irc_whois
{
    my $hashref = $_[ARG0];
    my $nick = $hashref->{nick};
    my $user = $hashref->{user};
    my $host = $hashref->{host};

    $userhost = "${user}\@$host";         # ~user@host
    $fullnick = "${nickname}!$userhost";  # nick!~user@host

    if ($connected) {
        if ($log_path ne '') {
            foreach my $key (sort keys $hashref->%*) {
                my $val = $hashref->{$key};
                $val = conv_date($val) if $key eq 'signon';

                plog(1, 1, 0, 1, "$key => $val");
            }
        }

        $connected = 0;
    }

    return;
}

# Log whenever someone changes pcre2bot's channel modes, or pcre2bot changes its
# user and channel modes.
#
# Note that irc_chan_mode and irc_user_mode can be used to parse individual mode
# changes, but for now it is not necessary.
sub irc_mode
{
    my ($who, $channel, $mode) = @_[ARG0 .. ARG2];
    my $mask = "@_[ARG3 .. $#_]" // '';
    my $nick = parse_user $who;

    pdump('$mask', $mask);

    if ($log_path ne '') {
        # pcre2bot's nick or fullnick matches a MODE mask set by someone.
        if ($nick ne $nickname) {
            if ($mask eq $nickname || matches_mask($mask, $fullnick)) {
                plog(1, 1, 0, 1, "$who changes $mask mode in $channel to $mode");
            }
        }

        # pcre2bot's own MODE changes.
        if ($nick eq $nickname) {
            plog(1, 1, 0, 1, "$nick changes usermode to $mode")            if $channel eq $nickname;
            plog(1, 1, 0, 1, "$nick changes $channel mode to $mode $mask") if $channel ne $nickname;
        }
    }

    return;
}

# Log whenever pcre2bot joins a channel.
sub irc_join
{
    my ($who, $channel) = @_[ARG0, ARG1];
    my $nick = parse_user $who;

    plog(1, 1, 0, 1, "$nick joins $channel") if $nick eq $nickname && $log_path ne '';
    return;
}

# Log whenever pcre2bot leaves a channel.
sub irc_part
{
    my ($who, $channel) = @_[ARG0 .. ARG1];
    my $message = $_[ARG2] // '';
    my $nick    = parse_user $who;

    plog(1, 1, 0, 1, "$nick leaves ${channel}: $message") if $nick eq $nickname && $log_path ne '';
    return;
}

# Log whenever pcre2bot quits IRC (or gets KILLed).
sub irc_quit
{
    my ($who, $message, $common_channels) = @_[ARG0 .. ARG2];
    my $nick = parse_user $who;

    if ($nick eq $nickname) {
        plog(2, 1, 0, 1, "$nick quits IRC: $message") if $log_path ne '';

        # Do not reconnect bot on manual /quit.
        $irc->plugin_del('Connector');
    }

    return;
}

# Log whenever someone kicks pcre2bot from a channel.
sub irc_kick
{
    my ($kicker, $channel, $nick, $reason) = @_[ARG0 .. ARG3];

    plog(1, 1, 0, 1, "$kicker kicks $nickname from ${channel}: $reason") if $nick eq $nickname && $log_path ne '';
    return;
}

# Update and log whenever pcre2bot changes its nick.
sub irc_nick
{
    my ($who, $new_nick, $common_channels) = @_[ARG0 .. ARG2];
    my $nick = parse_user $who;

    $nickname = $new_nick if $who eq $fullnick;
    plog(1, 1, 0, 1, "$nick changes nick to $new_nick") if $log_path ne '';

    return;
}

# Log whenever a channel topic is set or unset by pcre2bot.
sub irc_topic
{
    my ($who, $channel, $topic, $topic_old) = @_[ARG0 .. ARG3];
    my $nick = parse_user $who;

    pdump('$topic_old', $topic_old);
    $topic_old = $topic_old->{Value};

    plog(1, 1, 0, 1, "$nick changes topic for $channel from '${topic_old}' to '${topic}'") if $log_path ne '';

    return;
}

# Log whenever pcre2bot receives a CTCP query.
sub irc_ctcp
{
    my ($type, $who, $target) = @_[ARG0 .. ARG2];

    plog(1, 1, 0, 1, "$who sends a CTCP $type query to $nickname") if $target->[0] eq $nickname && $log_path ne '';
    return;
}

# Log whenever someone invites pcre2bot to another channel.
sub irc_invite
{
    my ($who, $channel) = @_[ARG0, ARG1];

    plog(1, 1, 0, 1, "$who invites $nickname to $channel") if $log_path ne '';
    return;
}

# Print and/or log when the IRC component has been asked to shutdown, and exit cleanly.
sub irc_shutdown
{
    my ($heap, $session_id) = @_[HEAP, ARG0];

    pmsg(2, 0, "Shutting down session ID ${session_id} and exiting") if $was_connected;

    $readline = '';
    delete $heap->{readwrite_main};
    delete $heap->{readwrite_raw};
    print "\n";  # Get rid of unterminated '> ' prompt.

    exit 0;
}

# Print and/or log whenever a socket connection to an IRC server closes down.
sub irc_disconnected
{
    my $server = $_[ARG0];

    pmsg(2, 0, "Lost connection to $server");
    return;
}

# Print and/or log whenever the IRC server sends an ERROR message.
sub irc_error
{
    my $err = $_[ARG0];

    pmsg(2, 0, "Server error occurred: $err");
    return;
}

# Print and/or log when a connection could not be established to the IRC server.
sub irc_socketerr
{
    my $err = $_[ARG0];

    pmsg(2, 0, "Socket error occurred: $err");
    return;
}

# Print and/or log when an error occurs while executing a plugin handler.
sub irc_plugin_error
{
    my $err = $_[ARG0];
    my ($plugin_alias, $plugin_object) = @_[ARG1 .. ARG2] // '';

    pmsg(2, 0, "Plugin $plugin_alias error occurred: $err");
    return;
}

# Reply to any PRIVMSG in channel that addresses the bot commands.
sub irc_public
{
    # E.g. ':ryoskzypu!~ryoskzypu@user/ryoskzypu PRIVMSG #regex :pcre2bot: help'
    my ($kernel, $heap, $who, $command, $message) = @_[KERNEL, HEAP, ARG0 .. ARG2];
    my ($nick, $user, $host) = parse_user $who;
    my $userhost = "${user}\@$host";
    my $channel  = $command->[0];

    $heap->{channel} = $channel;
    $heap->{nick}    = "${nick}: ";

    dump_privmsg($message);
    parse_privmsg($kernel, $heap, $userhost, $heap->{nick}, $channel, $message) if $nick ne $nickname && is_userhost_allowed($userhost);

    return;
}

# Reply to any private PRIVMSG that addresses the bot commands.
sub irc_msg
{
    # E.g. ':ryoskzypu!~ryoskzypu@user/ryoskzypu PRIVMSG pcre2bot :pcre2bot: help'
    my ($kernel, $heap, $who, undef, $message) = @_[KERNEL, HEAP, ARG0 .. ARG2];
    my ($nick, $user, $host) = parse_user $who;
    my $userhost = "${user}\@$host";

    $heap->{channel} = $nick;
    $heap->{nick}    = '';

    dump_privmsg($message);
    parse_privmsg($kernel, $heap, $userhost, '', $nick, $message) if $nick ne $nickname && is_userhost_allowed($userhost);

    return;
}

# pcre2test subroutines

# Parse PRIVMSG before sending it to pcre2test.
#
# Usage:
#   trigger> /pattern/modifiers subject
#   "        s/pattern/replacement/modifiers subject
#
#   nick: command
#
# Modifiers are separated by a comma, also short modifiers are concatenated and
# put before long modifiers.
# Note that the same rules apply to subject modifiers '\=...'.
#
# Commands are put after the bot nick with an optional colon or comma suffix. The
# nick requirement is not needed on private messages.
#
# Triggers:
#   re>        show default output
#   rec>       "    callouts
#   rev>       "    verbose callouts
#
# Commands:
#   help       show help
#   version    "    PCRE2 version
#   !command   same as input /commands but only for authorized userhosts
#
# Examples:
#   re> /(?<=ab)c/ abc
#   re> s/abc/<$0>/g abc
#   pcre2bot: version
#   pcre2bot: !join #regex
#
# Notes:
#   - The trigger's pattern and subject must be separated by spaces '\x20', since
#     newlines on IRC terminates a message and IRC does not support multiline
#     messages in the original spec.
#
#     Thus the drawback is that modifiers cannot have spaces, specially the 'replace=...'
#     modifier, so a space must be escaped to be included, e.g. 'replace=some\ text'.
#     Commas are also not allowed and must be escaped aswell, because they are
#     modifiers separators.
#     The s/// syntax can be used to avoid these issues.
#     There are some problems to show a literal backslash before a space or comma,
#     but at this point just use s///.
#
#   - pcre2test trim leading and trailing spaces, so spaces need to be encoded
#     in hex notation to be included, e.g. '/ abc / \x20abc\x20'.
#
#   - To prevent spam, only one subject test is allowed per trigger invocation,
#     and pcre2test outputs that exceed the $max_irc_lines variable are uploaded
#     to a pastebin service.
#     Also, the number of lines uploaded to the pastebin service is limited by
#     the $max_paste_lines variable.
#
#   - IRC messages must have a limit of 512 bytes according to the spec, thus the
#     tests are also limited.
#
#   - Newlines in the pattern are valid in pcre2test, but IRC is line oriented
#     and chats must not be spammed.
#     Also pcre2test interprets trailing newlines as subjects separators, so a
#     '\n' escape code must be used for multiline matches.
#
#   - See pcre2test(1) for more details.
#
# TODO:
#   - Make tests to assert if pcre2test can be abused or crash user's machine and
#     limit some resources and modifiers to prevent abuse. The limits must be
#     configurable by the bot.
#     pcre2test seems to not use much memory, even for very large regexes. The
#     real problem is the callout trigger output that is gonna be upload to a pastebin
#     service; so there has to be some limitation, because it can easily be abused
#     with large outputs.
#     regex101 limits its debugger to 1k steps, and it seems to have a limit of
#     133k steps from regexes prone to DoS.
#     See https://www.regular-expressions.info/redos.html.
#  -  Based on tests, pcre2test default heap/match/depth are reasonable and close
#     to regex101's, so the only relevant limit to set is the callout line count.
#     Perhaps a line count limit of 1k is reasonable, even though some pastebin
#     services have a large file size limit.
#
#   - Add a limitation on the pastebin service, to prevent abuse and blocking of
#     user's IP.
#     Maybe a count limit for each userhost that uploads pcre2test output to a
#     pastebin, e.g. 10 per day.
#   - Create a file on pcre2test's repo with the /help usage output for the !help
#     command, and add the link to its privmsg command.
sub parse_privmsg
{
    my ($kernel, $heap, $userhost, $nick, $channel, $message) = @_;
    my $pat_mods  = $def_pat_mods;
    my $subj_mods = $def_subj_mods;

    # Commands
    if ($nick ne '' && $message =~ /
                                       \A
                                       \Q$nickname\E[:,]?+
                                       \x{20}
                                       $commands_rgx
                                       \z
                                   /x
                                   ||
        # Nick prefix before commands is not a requirement on private messages.
        ($nick eq '' && $message =~ /
                                        \A
                                        $commands_rgx
                                        \z
                                    /x)) {
        # help
        if (defined $+{cmd1}) {
            $irc->yield(privmsg => $channel => "${nick}Usage: trigger> /pattern/mods subject; trigger> s/pattern/replace/mods subject; nick: command");
            $irc->yield(privmsg => $channel => "${nick}Triggers: re> (default output), rec> (callouts), rev> (verbose callouts)");
            $irc->yield(privmsg => $channel => "${nick}Commands: help (show help), version (PCRE2 version)");
            $irc->yield(privmsg => $channel => "${nick}E.g. re> /(?<=ab)c/ abc; re> s/abc/<\$0>/g abc; pcre2bot: version");
        }
        # version
        elsif (defined $+{cmd2}) {
            run_pcre2test($kernel, $heap, 1, '', '', '');
        }
        # !command
        elsif (defined $+{in_cmd}) {
            my $target = ($nick eq '' ? 'private' : $channel);

            if (! @userhosts_auth || ! grep { $_ eq $userhost } @userhosts_auth) {
                # Ignore and report if a user is not authorized.
                pmsg(1, 0, "Unauthorized '${userhost}' tries to run command in ${target}: '${message}'");
                return;
            }

            my $fullcmd = $+{in_cmd};

            if ($fullcmd =~ s|\A!|/|) {
                # Get and validate /command before ReadLine's parsing.

                my ($cmd) = $fullcmd =~ /\A([^\h]*+)\h*+/;

                if (! grep { $_ =~ /\A\Q$cmd\E/ } @commands) {
                    $irc->yield(privmsg => $channel => "${nick}invalid '${cmd}' command");
                    return;
                }

                pmsg(1, 0, "Authorized '${userhost}' runs '${cmd}' in ${target}: '${message}'");

                # Show a webpage link for the !help command to avoid flood ban,
                # because the output is huge. Maybe a link to a help file from
                # pcre2bot's repo.
                if ($cmd =~ m{\A/help\h*+}) {
                    $irc->yield(privmsg => $channel => "${nick}<help link>");
                    return;
                }

                parse_command($channel, $nick, $fullcmd);
            }
        }
    }
    # Triggers
    elsif ($message =~ /
                           \A
                           (?>
                               (?'trig1' rev) | (?'trig2' rec) | (?'trig3' re)
                           )
                           >(?'input'
                               \x{20}(?'re_input' [^\n]++)?+
                           )?+
                           \z
                       /x) {
        my $input;
        my $subst          = 0;
        my $delimiter      = '';
        my $pattern        = '';
        my $replacement    = '';
        my $pat_modifiers  = '';
        my $subject        = '';
        my $subj_modifiers = '';
        my $regexp;
        my $pos_line;

        # Set options modifiers

        # Verbose callouts
        if (defined $+{trig1}) {
            $pat_mods  .= ',auto_callout,info';
            $subj_mods .= ',callout_extra,substitute_callout';
            #$subj_mod .= ',callout_extra,callout_capture';

            $heap->{trigger} = 'verbose';
        }
        # Callouts
        elsif (defined $+{trig2}) {
            $pat_mods  .= ',auto_callout';
            $subj_mods .= ',substitute_callout';
            $heap->{trigger} = 'callouts';
        }
        # Default
        elsif (defined $+{trig3}) {
            $subj_mods .= ',callout_none';
            $heap->{trigger} = 'default';
        }

        if (defined $+{input}) {
            if (defined $+{re_input}) {
                $input = $+{re_input};
            }
            else {
                $irc->yield(privmsg => $channel => "${nick}missing pattern and subject");
                return;
            }
        } else {
            $irc->yield(privmsg => $channel => "${nick}missing pattern and subject");
            return;
        }

        # Get the regexp and subject from input.
        #
        # Note that pcre2test allows spaces in the modifiers list, but not here
        # since pattern and subjects must be separated by a space.
        #
        # TODO:
        #   - Restrict modifiers in an allow list that is configurable by the bot,
        #     because some modifiers can potentially cause problems.
        #     Perhaps the single letter modifiers are enough, so check if there
        #     is a long modifier that could be useful. *OK*
        #
        #   - Decide if '\=...' subjects modifiers should be allowed. It can be
        #     disabled with the subject_literal modifier, however backslash interpretation
        #     will be disabled aswell. *OK*

        # Start of /pattern/modifiers
        {
            if ($input =~ m{
                              \A
                              \h*+
                              (?'delimiter' $delimiter_rgx)  # Pattern opening delimiter
                          }xgc) {
                $delimiter = $+{delimiter};
            }
            # Start of s/pattern/replacement/modifiers
            elsif ($input =~ m{
                                 \A
                                 \h*+
                                 s
                                 (?'delimiter' $delimiter_rgx)
                             }xgc) {
                $delimiter = $+{delimiter};
                $subst     = 1;
            }
            else {
                $irc->yield(privmsg => $channel => "${nick}invalid '${input}' pattern opening delimiter");
                return;
            }

            pdbg("\$delimiter: '${delimiter}'");

            # Position where the last global match ended.
            get_last_pos(\$input, 20);
        }

        # Pattern
        {
            if ($input =~ m{
                              \G
                              (?'pattern'
                                  (?> \\.
                                      | (?!$delimiter) [^\\]
                                  )*+
                              )
                          }xgc) {
                $pattern = $+{pattern};
            }

            if ($pattern eq '') {
                $irc->yield(privmsg => $channel => "${nick}missing pattern");
                return;
            } else {
                pdbg("\$pattern: '${pattern}'");
            }

            get_last_pos(\$input, 20);
        }

        # Pattern closing delimiter
        {
            if ($input !~ m{\G$delimiter}gc) {
                $irc->yield(privmsg => $channel => "${nick}missing or invalid pattern closing delimiter");
                return;
            } else {
                pdbg("\$delimiter: '${delimiter}'");
            }

            get_last_pos(\$input, 20);
        }

        # Replacement string in s/pattern/replacement/modifiers
        {
            if ($subst) {
                if ($input =~ m{
                                  \G
                                  (?'replacement'
                                      (?> \\[^\n]
                                          | (?!$delimiter) [^\\]
                                      )*+
                                  )
                              }xgc) {
                    $replacement = $+{replacement};
                }

                if ($replacement eq '') {
                    $irc->yield(privmsg => $channel => "${nick}missing replacement string");
                    return;
                } else {
                    pdbg("\$replacement: '${replacement}'");
                }

                get_last_pos(\$input, 20);

                # Replacement closing delimiter
                if ($input !~ m{\G$delimiter}gc) {
                    $irc->yield(privmsg => $channel => "${nick}missing or invalid replacement closing delimiter");
                    return;
                } else {
                    pdbg("\$delimiter: '${delimiter}'");
                }

                get_last_pos(\$input, 20);
            }
        }

        # Pattern modifiers
        {
            if ($input =~ m{
                              \G
                              (?'modifiers' (?&get_modifiers))?+ (?!$delimiter)

                              (?(DEFINE)
                                  # Single letter modifiers must be concatenated and come before longs.
                                  (?'get_modifiers'
                                      (?&modifier_short)
                                      (?> ,(?&modifier_long))*+
                                      |
                                      (?&modifier_long)
                                      (?> ,(?&modifier_long))*+
                                  )?+

                                  # See 'pcre2test -LM' and pcre2test(1) for the complete list.

                                  (?'modifier_short' $mod_short_rgx)

                                  (?'modifier_long'
                                      (?>
                                          -?
                                          \b
                                          (?>
                                              allow_empty_class | allow_lookaround_bsk | allow_surrogate_escapes | alt_bsux | alt_circumflex | alt_extended_class | alt_verbnames
                                              | anchored | ascii_all | ascii_bsd | ascii_bss | ascii_bsw | ascii_digit | ascii_posix | auto_callout | auto_possess_off | auto_possess
                                              | aftertext | allaftertext | allcaptures | allusedtext | allvector | altglobal
                                              | bad_escape_is_literal | bincode
                                              | callout_info | caseless_restrict | caseless | convert_length
                                              | debug | dollar_endonly | dotall | dotstar_anchor_off | dotstar_anchor | dupnames
                                              | endanchored | escaped_cr_is_lf | expand | extended_more | extended | extra_alt_bsux
                                              | firstline | framesize | fullbincode
                                              | global
                                              | hex | heapframes_size
                                              | info
                                              | jitverify | jitfast
                                              | literal
                                              | match_line | match_invalid_utf | match_unset_backref | match_word | mark
                                              | memory | multiline
                                              | never_backslash_c | never_callout | never_ucp | never_utf | no_auto_capture | no_auto_possess | no_bs0 | no_dotstar_anchor
                                              | no_start_optimize | no_utf_check | null_context | null_pattern
                                              | optimization_full | optimization_none
                                              | posix_nosub | posix | pushcopy | pushtablescopy | push | python_octal
                                              | start_optimize_off | start_optimize | subject_literal | startchar | substitute_callout | substitute_case_callout | substitute_extended
                                              | substitute_literal | substitute_matched | substitute_overflow_length | substitute_replacement_only
                                              | substitute_unknown_unset | substitute_unset_empty
                                              | turkish_casing
                                              | ucp | ungreedy | use_length | use_offset_limit | utf8_input | utf
                                          )
                                          \b
                                      )
                                      |
                                      # Modifiers that must contain a value.
                                      (?>
                                          \b
                                          bsr
                                          | callout_error | callout_fail | convert_glob_escape | convert_glob_separator | convert | copy
                                          | get
                                          | heap_limit
                                          | jitstack | jit
                                          | locale
                                          | match_limit | max_pattern_compiled_length | max_pattern_length | max_varlookbehind
                                          | newline
                                          | offset_limit | offset | ovector
                                          | parens_nest_limit | posix_startend
                                          | recursion_limit | regerror_buffsize | replace
                                          | substitute_skip | substitute_stop | stackguard | startoffset
                                          | tables
                                          \b
                                      )
                                      =
                                      # Allows '\ ' in 'replace=foo\ bar\ baz' to be included.
                                      # Also '\,' in 'replace=foo\,bar\,baz'.
                                      (?> (?!$delimiter)[^,\s\\]
                                          | \\[^\n,] | \\,
                                      )*+
                                      |
                                      # Force a failure if nothing matches.
                                      (*COMMIT)(*FAIL)
                                  )
                              )
                          }xgc) {
                $pat_modifiers = $+{modifiers};
            }

            # Get the string from the last match position, which are the modifiers.
            $pos_line = get_last_pos(\$input, 50);

            # Error out only on invalid modifiers, so empty modifiers are accepted.
            if ($pat_modifiers eq '' && $pos_line ne '' && $pos_line !~ /^\x{20}/) {
                $irc->yield(privmsg => $channel => "${nick}invalid pattern '${pos_line}' modifiers");
                return;
            } else {
                pdbg("\$pat_modifiers: '${pat_modifiers}'\n");
            }

            # Check if a pattern modifier is in the allow list.
            if ($pat_modifiers ne '') {
                return unless check_modifiers($channel, $nick, \@pat_mods_allow, $pat_modifiers);
            }

            # s/// replacement has priority over the 'replace' modifier, so skip this
            # process on s///.
            if (! $subst) {
                # Parse the 'replace' modifier value.
                $pat_modifiers = parse_replace_mod($pat_modifiers);

                pdbg("\$pat_modifiers: '${pat_modifiers}'");

                $regexp = "${delimiter}${pattern}${delimiter}$pat_modifiers";
            }
            else {
                # Parse the s/// replacement string.
                if ($replacement =~ /,/) {
                    # Replace all commas with a unique escape char '\034'.
                    if ($replacement =~ s/,/\o{034}/g) {
                        $conv_uniq = 1;
                        pdbg("\$replacement: '${replacement}'");
                    }
                }

                $regexp = "${delimiter}${pattern}${delimiter}${pat_modifiers},replace=${replacement}";
            }

            pdbg("\$regexp: '${regexp}'\n");
        }

        # End of /pattern/modifiers or /s/pattern/replacement/modifiers;
        # Start of subject string
        {
            if ($subj_literal && $input =~ m{
                                               \G
                                               # Do not validate subject modifiers
                                               (?>
                                                   \x{20}++
                                                   (?'subject'[^\n]++)
                                               )?+
                                               \z
                                           }xgc) {
                $subject = $+{subject};
            }
            elsif (! $subj_literal && $input =~ m{
                                                    \G
                                                    # Validate subject modifiers in '\=...'
                                                    (?>
                                                        \x{20}++
                                                        (?'subject' (?> (?!\\=)[^\n])*+)
                                                        (?>
                                                            \\=
                                                            (?'modifiers' (?&get_modifiers))?+
                                                        )?+
                                                    )?+

                                                   (?(DEFINE)
                                                       # Single letter modifiers must be concatenated and come before longs.
                                                       (?'get_modifiers'
                                                           (?&modifier_short)
                                                           (?> ,(?&modifier_long))*+
                                                           |
                                                           (?&modifier_long)
                                                           (?> ,(?&modifier_long))*+
                                                       )?+

                                                       # See 'pcre2test -LM' and pcre2test(1) for the complete list.

                                                       (?'modifier_short' \b[g]++\b)

                                                       (?'modifier_long'
                                                           (?>
                                                               -?
                                                               \b
                                                               (?>
                                                                   anchored | aftertext | allaftertext | allcaptures | allusedtext | allvector | altglobal
                                                                   | callout_capture | callout_extra | callout_no_where | callout_none | copy_matched_subject
                                                                   | endanchored
                                                                   | dfa_restart | dfa_shortest | dfa | disable_recurseloop_check
                                                                   | find_limits_noheap | find_limits
                                                                   | heapframes_size
                                                                   | mark | memory
                                                                   | no_jit | no_utf_check | notbol | notempty | notempty_atstart | noteol | null_context | null_replacement | null_subject
                                                                   | partial_hard | partial_soft | ph | ps
                                                                   | global | getall
                                                                   | heapframes_size
                                                                   | mark
                                                                   | startchar | substitute_callout | substitute_case_callout | substitute_extended | substitute_literal | substitute_matched
                                                                   | substitute_overflow_length | substitute_replacement_only | substitute_unknown_unset | substitute_unset_empty
                                                                   | zero_terminate
                                                               )
                                                               \b
                                                           )
                                                           |
                                                           # Modifiers that must contain a value.
                                                           (?>
                                                               \b
                                                                   callout_data | callout_error | callout_fail | copy
                                                                   | depth_limit
                                                                   | get
                                                                   | heap_limit
                                                                   | jitstack
                                                                   | match_limit
                                                                   | offset_limit | offset | ovector
                                                                   | recursion_limit | replace
                                                                   | substitute_skip | substitute_stop | startoffset
                                                               \b
                                                           )
                                                           =
                                                           # Allows '\ ' in 'replace=foo\ bar\ baz' to be included.
                                                           # Also '\,' in 'replace=foo\,bar\,baz'.
                                                           (?> [^,\s\\]++ | \\[^\n,] | \\,)++
                                                       )
                                                    )
                                                    \z
                                                }xgc) {
                $subject        = $+{subject};
                $subj_modifiers = $+{modifiers} // '';
            }

            # Get the string from the last match position, which are the modifiers.
            $pos_line = get_last_pos(\$input, 50);

            # Error out only on invalid subject modifiers.
            if ($subj_modifiers eq '' && $pos_line ne '') {
                $irc->yield(privmsg => $channel => "${nick}invalid subject '${pos_line}' modifiers");
                return;
            } else {
                pdbg("\$subj_modifiers: '${subj_modifiers}'\n");
            }

            # Check if a subject modifier is in the allow list.
            if ($subj_modifiers ne '') {
                return unless check_modifiers($channel, $nick, \@subj_mods_allow, $subj_modifiers);
            }

            # Parse the 'replace' modifier value.
            $subj_modifiers = parse_replace_mod($subj_modifiers);
            pdbg("\$subj_modifiers: '${subj_modifiers}'");

            if ($subject eq '') {
                $irc->yield(privmsg => $channel => "${nick}missing subject string");
                return;
            } else {
                pdbg("\$subject:        '${subject}'");
                pdbg("\$subj_modifiers: '${subj_modifiers}'\n");
            }

            get_last_pos(\$input, 20);

            if ($subj_modifiers ne '') {
                $subject = "${subject}\\=$subj_modifiers";
                pdbg("\$subject:        '${subject}'");
            }
        }

        $subst        = 0;
        $subj_literal = 0;

        # Construct a single test that is a valid pcre2test input.
        $input = <<~_;
            $regexp
            $subject
            _

        # Send input to pcre2test's STDIN.
        run_pcre2test($kernel, $heap, 0, $pat_mods, $subj_mods, $input);
    }
}

# Parse the 'replace=...' modifier value.
sub parse_replace_mod
{
    my ($modifiers) = @_;

    if ($modifiers =~ /\breplace=\K(?> \\[^\n] | (?!\\)[^\x{20},])++/x) {
        my $match     = $&;
        my $match_len = length $match;
        my $start     = $-[0];
        my $end       = $+[0];

        pdbg("\$match:       '${match}'");
        pdbg("\$match_len:    ${match_len}");
        pdbg("\$start,\$end: '${start},${end}\n");

        # Replace all escaped commas with a unique escape char '\034'.
        if ($match =~ s/\\,/\o{034}/g) {
            $conv_uniq = 1;
            pdbg("\$match:       '${match}'");
        }

        # Replace all escaped spaces '\ ' with a space.
        my $replace = $match =~ s/\\(\x{20})/$1/gr;
        my $replaced = substr $modifiers, $start, $match_len, $replace;

        pdbg("\$replace:     '${replace}'");
        pdbg("\$replaced:    '${replaced}'\n");
    }

    return $modifiers;
}

# Check if a modifier from pattern/subject modifiers is allowed to be used.
sub check_modifiers
{
    my ($channel, $nick, $list, $modifiers)  = @_;
    my @split_mods = split /(?<!\\),/, $modifiers;

    pdump('@split_mods', \@split_mods);

    if ($list->@*) {
        # Check short modifiers.
        if ($split_mods[0] =~ /
                                  $mod_short_rgx
                                  |
                                  # Force a failure on backtracking, so strings like 'replace=x'
                                  # will not match a short modifier.
                                  (*COMMIT)(*FAIL)
                              /x) {
            pdbg("'$split_mods[0]' is a short modifier");

            foreach my $i (split //, $split_mods[0]) {
                pdbg("\$i: '${i}'");

                if (! grep { $_ eq $i } $list->@*) {
                    pdbg("short modifier '${i}' is not in allow list");
                    $irc->yield(privmsg => $channel => "${nick}short '${i}' modifier is not allowed");

                    return 0;
                }
            }
            shift @split_mods;
        }
    }

    # Check long modifiers.
    foreach my $i (@split_mods) {
        $i =~ s/=[^\n]++\z//g;

        if ($i eq 'subject_literal') {
            pdbg('subject_literal pattern modifier is found');
            $subj_literal = 1;
        }

        if ($list->@* && ! grep { $_ eq $i } $list->@*) {
            pdbg("modifier '${i}' is not in allow list");
            $irc->yield(privmsg => $channel => "${nick}long '${i}' modifier is not allowed");

            return 0;
        }
    }

    return 1;
}

# Get the position where the last regexp global match ended for the variable.
sub get_last_pos
{
    my ($var, $len) = @_;
    my $last_pos    = pos $var->$*;

    if (defined $last_pos && defined $len) {
        my $pos_line = unpack "x$last_pos a$len", $var->$*;

        if (defined $pos_line) {
            pdbg("\$last_pos:  ${last_pos}");
            pdbg("\$pos_line: '${pos_line}'\n");

            return $pos_line;
        }
    }
}

# Run pcre2test
sub run_pcre2test
{
    my ($kernel, $heap, $version, $pat_mods, $subj_mods, $input) = @_;
    my $program;

    if ($version) {
        $program = ['pcre2test', '-q', '--version'];
    }
    else {
        $program = ['pcre2test', '-q', '-pattern', $pat_mods, '-subject', $subj_mods];
    }

    my $child = POE::Wheel::Run->new(
        Program     => $program,
        StdoutEvent => 'got_child_stdout',
        StderrEvent => 'got_child_stderr',
        CloseEvent  => 'got_child_close',
    );
    my $child_pid = $child->PID;
    my $child_id  = $child->ID;

    # Send input to pcre2test.
    $child->put($input);

    $kernel->sig_child($child_pid, 'got_child_signal');

    # Wheel events include the wheel's ID.
    $heap->{children_by_wid}{$child_id} = $child;

    # Signal events include the process ID.
    $heap->{children_by_pid}{$child_pid} = $child;

    pdbg("child PID $child_pid started as wheel $child_id");
}

# Upload pcre2test's output to a pastebin service.
sub get_pastebin
{
    my ($input) = @_;

    if ($primary_service eq '') {
        pdbg('primary pastebin service is not set');
        return;
    }

    $poe_kernel->post('curl', 'request', '_response', POST(
            $primary_service,
            Content_Type => 'form-data',
            Content => [
                'file' => [undef, 'filename', Content_Type => 'text/plain', Content => $input],
            ]
    ));

    return;
}

sub set_dumper
{
    $Data::Dumper::Terse = 1;
    $Data::Dumper::Useqq = 1;

    # Sort Dumper keys by numeric or alphabetic order.
    $Data::Dumper::Sortkeys = sub
    {
        my $hash = shift;

        return [
            join('', keys $hash->%*) =~ /\A\d+\z/ ? sort { $a <=> $b } keys $hash->%*
                                                  : sort keys $hash->%*
        ];
    };
}

sub set_options
{
    # Transform options warn messages.
    local $SIG{__WARN__} = sub {
        chomp (my $msg = shift);

        if ($msg =~ /\AUse of uninitialized value /) {
            print $msg;
            return;
        }

        $msg =~ tr/"/'/;
        err 2, "\L$msg\E";
    };

    GetOptions(
        'auto-conn|ac' => \$auto_conn,
        'debug|d'      => \$debug,
        'help|h'       => sub { print $usage; exit 0 },
        'pass|p'       => \$pass,
        'version|v'    => sub { print "$prog ${prog_ver}\n"; exit 0 },
    );

    if ($pass) {
        # Non-interactive STDIN
        if (! -t STDIN) {
            chomp ($nickserv_pass = <STDIN>);
        }
        # STDIN is opened to a TTY.
        else {
            print 'Enter NickServ password: ';

            # Disable TTY echo.
            system('/usr/bin/stty', '-echo'); die $! if ($? >> 8) > 0;

            chomp ($nickserv_pass = <STDIN>);

            system('/usr/bin/stty', 'echo'); die $! if ($? >> 8) > 0;
            print "\n";
        }
    }
}

# Configuration

# Initialize config file.
sub init_config
{
    my $config_file = shift @ARGV or err 2, 'missing config file';
    err 2, 'config file does not exist' unless -e $config_file;
    open my $fh, '<', $config_file or err 1, "failed to open $config_file";

    # Decode TOML config.

    my $toml = do { local $/; <$fh> };
    close $fh or warn $!;
    ($config, my $error) = from_toml($toml);

    if ($error ne '') {
        chomp $error;
        err 1, "failed to decode config file\n$error";
    }

    print '$config = ' . Dumper $config if $debug;
}

# Set config TLS variable and check its certificate.
sub set_config_tls
{
    $tls      = $config->{server}->{use_tls};
    $tls_cert = $config->{server}->{tls_cert};
    $tls_key  = $config->{server}->{tls_key};

    if ($tls_cert ne '' && $tls_key eq '') {
        err 1, 'missing certificate key';
    }
    elsif ($tls_key ne '' && $tls_cert eq '') {
        err 1, 'missing certificate';
    }
    elsif ($tls_cert ne '' && $tls_key ne '') {
        err 1, "'tls' key value must be set to 1" unless $tls;
        err 2, 'NickServ password is unnecessary with a TLS cert' if $pass && $nickserv_pass ne '';
    }
}

# Get environment variables.
sub get_env_vars
{
    if (defined $ENV{NICKSERV_PASS} && $nickserv_pass eq '' && $tls_cert eq '') {
        print "Getting NICKSERV_PASS environment variable.\n" if $debug;
        $nickserv_pass = $ENV{NICKSERV_PASS};
    }
}

# Set config variables.
sub set_config_vars
{
    $nickname      = $config->{server}->{nickname};
    $username      = $config->{server}->{username};
    $ircname       = $config->{server}->{ircname};
    $usermode      = $config->{server}->{usermode};
    $server        = $config->{server}->{server};
    $port          = $config->{server}->{port};
    $log_path      = $config->{server}->{log_path};
    $log_private   = $config->{server}->{log_private};
    $log_public    = $config->{server}->{log_public};
    $log_raw       = $config->{server}->{log_raw};
    $nickserv_pass = $config->{server}->{nickserv_password} if $nickserv_pass eq '' && $tls_cert eq '';
    @channels      = ($config->{server}->{channels}->@*);

    # Userhost lists (~user@host)
    @userhosts_allow  = ($config->{server}->{userhosts_allow}->@*);
    @userhosts_ignore = ($config->{server}->{userhosts_ignore}->@*);
    @userhosts_auth   = ($config->{server}->{userhosts_auth}->@*);

    # Default options modifiers
    $def_pat_mods  = $config->{pcre2test}->{pattern_modifiers};
    $def_subj_mods = $config->{pcre2test}->{subject_modifiers};

    # Modifiers allow lists
    @pat_mods_allow  = ($config->{pcre2test}->{pattern_mods_allow}->@*);
    @subj_mods_allow = ($config->{pcre2test}->{subject_mods_allow}->@*);

    # Pastebin services

    $max_irc_lines     = $config->{pcre2test}->{max_irc_lines};
    $max_paste_lines   = $config->{pcre2test}->{max_paste_lines};

    err 1, "max_irc_lines value is not a number"   if $max_irc_lines   !~ $num_rgx;
    err 1, "max_paste_lines value is not a number" if $max_paste_lines !~ $num_rgx;

    $primary_service   = $config->{pcre2test}->{primary_service};
    @fallback_services = ($config->{pcre2test}->{fallback_services}->@*);
}

# Open the log filehandles if config asks to log.
sub check_log
{
    if ($log_path ne '') {
        my $filepath = $log_path =~ s|/\z||r;  # Trim trailing slash.
        mkdir $filepath, 0700 or $!{EEXIST}    # Do not err if directory exists.
                              or err 1, "failed to create directory '${filepath}': $!\n";

        open $main_log_fh, '>>', "${filepath}/main.log" or err 1, 'failed to open main.log filehandle';
        open $raw_log_fh,  '>>', "${filepath}/raw.log"  or err 1, 'failed to open raw.log filehandle' if $log_raw;
    }
}

# Check if pcre2test is installed on user's system.
sub check_pcre2test
{
    # Exit with an error if pcre2test is not found on $PATH.
    system '/bin/sh', '-c', "command -v pcre2test > /dev/null";

    err 1, 'pcre2test is not installed' if (($? >> 8) > 0);
}

# POE

# Initialize POE framework objects.
sub init_poe
{
    my %opts = (
        Nick     => $nickname,
        Username => $username,
        Ircname  => $ircname,
        Server   => $server,
        Port     => $port,
        UseSSL   => $tls,
        SSLCert  => $tls_cert,
        SSLKey   => $tls_key,
        Raw      => 1,
    );

    # Create a PoCo-IRC object.
    $irc = POE::Component::IRC::State->spawn(
        %opts,
        WhoJoiners => 0,
    ) or die "failed to create PoCo-IRC object $!";

    print "$nickname ${server}\n";
    print $irc->VERSION, "\n";

    # Create a PoCo-IRC session.
    POE::Session->create(
        package_states => [
            main => [
                qw<
                    _start
                    _default
                    _response
                    rl_handle_input
                    got_child_stdout
                    got_child_stderr
                    got_child_close
                    got_child_signal
                    irc_001
                    irc_329
                    irc_333
                    irc_354
                    irc_367
                    irc_718
                    irc_728
                    irc_raw
                    irc_raw_out
                    irc_connected
                    irc_identified
                    irc_whois
                    irc_mode
                    irc_join
                    irc_part
                    irc_quit
                    irc_kick
                    irc_nick
                    irc_topic
                    irc_ctcp
                    irc_invite
                    irc_shutdown
                    irc_disconnected
                    irc_error
                    irc_socketerr
                    irc_plugin_error
                    irc_public
                    irc_msg
                >
            ],
        ],

        heap => {irc => $irc},
    ) or die "failed to create PoCo-IRC session $!";

    # Create a PoCo-Curl object.
    #$curl = POE::Component::Curl::Multi->spawn(
    #    alias           => 'curl',
    #    timeout         => 15,
    #    agent           => 'curl/8.12.1',
    #    max_concurrency => 10,
    #) or die "failed to create PoCo-Curl object $!";
}

END {
    $irc->yield(unregister => 'all') if defined $irc;
}

# Main
set_dumper();
set_options();
init_config();
set_config_tls();
get_env_vars();
set_config_vars();
check_log();
check_pcre2test();
init_poe();
$poe_kernel->run();
